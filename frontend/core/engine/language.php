<?php

/*
 * This file is part of Fork CMS.
 *
 * For the full copyright and license information, please view the license
 * file that was distributed with this source code.
 */

/**
 * This class will store the language-dependant content for the frontend.
 *
 * @author Tijs Verkoyen <tijs@sumocoders.be>
 */
class FrontendLanguage
{
	/**
	 * Locale arrays
	 *
	 * @var	array
	 */
	private static $act = array(), $err = array(), $lbl = array(), 	$msg = array();

	/**
	 * The possible languages
	 *
	 * @var	array
	 */
	private static $languages = array('active' => array(), 'possible_redirect' => array());

	/**
	 * Build the language files
	 *
	 * @param string $language The language to build the locale-file for.
	 * @param string $application The application to build the locale-file for.
	 */
	public static function buildCache($language, $application)
	{
		$db = FrontendModel::getDB();

		// get types
		$types = $db->getEnumValues('locale', 'type');

		// get locale for backend
		$locale = (array) $db->getRecords(
			'SELECT type, module, name, value
			 FROM locale
			 WHERE language = ? AND application = ?
			 ORDER BY type ASC, name ASC, module ASC',
			array((string) $language, (string) $application)
		);

		// start generating PHP
		$value = '<?php' . "\n";
		$value .= '/**' . "\n";
		$value .= ' *' . "\n";
		$value .= ' * This file is generated by Fork CMS, it contains' . "\n";
		$value .= ' * more information about the locale. Do NOT edit.' . "\n";
		$value .= ' * ' . "\n";
		$value .= ' * @author Fork CMS' . "\n";
		$value .= ' * @generated	' . date('Y-m-d H:i:s') . "\n";
		$value .= ' */' . "\n";
		$value .= "\n";

		// loop types
		foreach($types as $type)
		{
			// default module
			$modules = array('core');

			// continue output
			$value .= "\n";
			$value .= '// init var' . "\n";
			$value .= '$' . $type . ' = array();' . "\n";

			// loop locale
			foreach($locale as $i => $item)
			{
				// types match
				if($item['type'] == $type)
				{
					// new module
					if(!in_array($item['module'], $modules))
					{
						$value .= '$' . $type . '[\'' . $item['module'] . '\'] = array();' . "\n";
						$modules[] = $item['module'];
					}

					// parse
					if($application == 'backend') $value .= '$' . $type . '[\'' . $item['module'] . '\'][\'' . $item['name'] . '\'] = \'' . str_replace('\"', '"', addslashes($item['value'])) . '\';' . "\n";
					else $value .= '$' . $type . '[\'' . $item['name'] . '\'] = \'' . str_replace('\"', '"', addslashes($item['value'])) . '\';' . "\n";

					// unset
					unset($locale[$i]);
				}
			}
		}

		$value .= "\n";
		$value .= '?>';

		// store
		SpoonFile::setContent(constant(mb_strtoupper($application) . '_CACHE_PATH') . '/locale/' . $language . '.php', $value);
	}

	/**
	 * Get an action from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function getAction($key)
	{
		// redefine
		$key = SpoonFilter::toCamelCase((string) $key);

		// if the action exists return it,
		if(isset(self::$act[$key])) return self::$act[$key];

		// otherwise return the key in label-format
		return '{$act' . $key . '}';
	}

	/**
	 * Get all the actions
	 *
	 * @return array
	 */
	public static function getActions()
	{
		return self::$act;
	}

	/**
	 * Get the active languages
	 *
	 * @return array
	 */
	public static function getActiveLanguages()
	{
		// validate the cache
		if(empty(self::$languages['active']))
		{
			// grab from settings
			$activeLanguages = (array) FrontendModel::getModuleSetting('core', 'active_languages');

			// store in cache
			self::$languages['active'] = $activeLanguages;
		}

		// return from cache
		return self::$languages['active'];
	}

	public static function parseLanguageList($languageList) 
	{
	    if (is_null($languageList)) {
	        if (!isset($_SERVER['HTTP_ACCEPT_LANGUAGE'])) {
	            return array();
	        }
	        $languageList = $_SERVER['HTTP_ACCEPT_LANGUAGE'];

	    }

	    $languages = array();
	    $languageRanges = explode(',', trim($languageList));
	    foreach ($languageRanges as $languageRange) {
	        if (preg_match('/(\*|[a-zA-Z0-9]{1,8}(?:-[a-zA-Z0-9]{1,8})*)(?:\s*;\s*q\s*=\s*(0(?:\.\d{0,3})|1(?:\.0{0,3})))?/', trim($languageRange), $match)) {
	            if (!isset($match[2])) {
	                $match[2] = '1.0';
	            } else {
	                $match[2] = (string) floatval($match[2]);
	            }
	            if (!isset($languages[$match[2]])) {
	                $languages[$match[2]] = array();
	            }
	            $languages[$match[2]][] = strtolower($match[1]);
	        }
	    }
	    krsort($languages);
	    return $languages;
	}

	public static function findMatches($accepted, $available) 
	{
	    $matches = array();
	    $any = false;
	    foreach ($accepted as $acceptedQuality => $acceptedValues) {
	        $acceptedQuality = floatval($acceptedQuality);
	        if ($acceptedQuality === 0.0) continue;
	        foreach ($available as $availableQuality => $availableValues) {
	            $availableQuality = floatval($availableQuality);
	            if ($availableQuality === 0.0) continue;
	            foreach ($acceptedValues as $acceptedValue) {
	                if ($acceptedValue === '*') {
	                    $any = true;
	                }
	                foreach ($availableValues as $availableValue) {
	                    $matchingGrade = self::matchLanguage($acceptedValue, $availableValue);
	                    if ($matchingGrade > 0) {
	                        $q = (string) ($acceptedQuality * $availableQuality * $matchingGrade);
	                        if (!isset($matches[$q])) {
	                            $matches[$q] = array();
	                        }
	                        if (!in_array($availableValue, $matches[$q])) {
	                            $matches[$q][] = $availableValue;
	                        }
	                    }
	                }
	            }
	        }
	    }
	    if (count($matches) === 0 && $any) {
	        $matches = $available;
	    }
	    krsort($matches);
	    return $matches;
	}

	public static function matchLanguage($a, $b)
	{
	    $a = explode('-', $a);
	    $b = explode('-', $b);
	    for ($i=0, $n=min(count($a), count($b)); $i<$n; $i++) {
	        if ($a[$i] !== $b[$i]) break;
	    }
	    return $i === 0 ? 0 : (float) $i / count($a);
	}
	/**
	 * Get the prefered language by using the browser-language
	 *
	 * @param bool[optional] $forRedirect Only look in the languages to redirect?
	 * @return string
	 */
	public static function getBrowserLanguage($forRedirect = true)
	{
		// browser language set
		if(isset($_SERVER['HTTP_ACCEPT_LANGUAGE']) && strlen($_SERVER['HTTP_ACCEPT_LANGUAGE']) >= 2)
		{
			$accepted = self::parseLanguageList($_SERVER['HTTP_ACCEPT_LANGUAGE']);

			
			// get languages
			$redirectLanguages = self::getRedirectLanguages();
			// transform to CSV for parsing
			$redirectLanguages = implode(",", $redirectLanguages);
			// parse available Fork Languages 
			$available = self::parseLanguageList($redirectLanguages);


			// find highest match between accepted browser languages and available languages
			// note: we can do array_shift(array_shift($var)) but following strict standards you can only pass variables by reference		
			$matches = self::findMatches($accepted, $available);
    		$matches = array_shift($matches);
    		$chosenOne = $matches[0];

			

			if($forRedirect)
				{
					// check in the redirect-languages
					if(!empty($chosenOne)) return $chosenOne;
				}
		}

		// fallback
		return SITE_DEFAULT_LANGUAGE;

	}



	/**
	 * Get an error from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function getError($key)
	{
		// redefine
		$key = SpoonFilter::toCamelCase((string) $key);

		// if the error exists return it,
		if(isset(self::$err[$key])) return self::$err[$key];

		// otherwise return the key in label-format
		return '{$err' . $key . '}';
	}

	/**
	 * Get all the errors
	 *
	 * @return array
	 */
	public static function getErrors()
	{
		return self::$err;
	}

	/**
	 * Get a label from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function getLabel($key)
	{
		// redefine
		$key = SpoonFilter::toCamelCase((string) $key);

		// if the error exists return it,
		if(isset(self::$lbl[$key])) return self::$lbl[$key];

		// otherwise return the key in label-format
		return '{$lbl' . $key . '}';
	}

	/**
	 * Get all the labels
	 *
	 * @return array
	 */
	public static function getLabels()
	{
		return self::$lbl;
	}

	/**
	 * Get a message from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function getMessage($key)
	{
		// redefine
		$key = SpoonFilter::toCamelCase((string) $key);

		// if the error exists return it,
		if(isset(self::$msg[$key])) return self::$msg[$key];

		// otherwise return the key in label-format
		return '{$msg' . $key . '}';
	}

	/**
	 * Get all the messages
	 *
	 * @return array
	 */
	public static function getMessages()
	{
		return self::$msg;
	}

	/**
	 * Get the redirect languages
	 *
	 * @return array
	 */
	public static function getRedirectLanguages()
	{
		// validate the cache
		if(empty(self::$languages['possible_redirect']))
		{
			// grab from settings
			$redirectLanguages = (array) FrontendModel::getModuleSetting('core', 'redirect_languages');

			// store in cache
			self::$languages['possible_redirect'] = $redirectLanguages;
		}

		// return
		return self::$languages['possible_redirect'];
	}

	/**
	 * Set locale
	 *
	 * @param string[optional] $language The language to load, if not provided we will load the language based on the URL.
	 * @param bool[optional] $force Force the language, so don't check if the language is active.
	 */
	public static function setLocale($language = null, $force = false)
	{
		// redefine
		$language = ($language !== null) ? (string) $language : FRONTEND_LANGUAGE;

		// validate language
		if(!$force && !in_array($language, self::getActiveLanguages())) throw new FrontendException('Invalid language (' . $language . ').');

		// validate file, generate it if needed
		if(!SpoonFile::exists(FRONTEND_CACHE_PATH . '/locale/en.php')) self::buildCache('en', 'frontend');
		if(!SpoonFile::exists(FRONTEND_CACHE_PATH . '/locale/' . $language . '.php')) self::buildCache($language, 'frontend');

		// init vars
		$act = array();
		$err = array();
		$lbl = array();
		$msg = array();

		// set English translations, they'll be the fallback
		require FRONTEND_CACHE_PATH . '/locale/en.php';
		self::$act = (array) $act;
		self::$err = (array) $err;
		self::$lbl = (array) $lbl;
		self::$msg = (array) $msg;

		// overwrite with the requested language's translations
		require FRONTEND_CACHE_PATH . '/locale/' . $language . '.php';
		self::$act = array_merge(self::$act, (array) $act);
		self::$err = array_merge(self::$err, (array) $err);
		self::$lbl = array_merge(self::$lbl, (array) $lbl);
		self::$msg = array_merge(self::$msg, (array) $msg);
	}
}

/**
 * FL (some kind of alias for FrontendLanguage)
 *
 * @author Tijs Verkoyen <tijs@sumocoders.be>
 */
class FL extends FrontendLanguage
{
	/**
	 * Get an action from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function act($key)
	{
		return FrontendLanguage::getAction($key);
	}

	/**
	 * Get an error from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function err($key)
	{
		return FrontendLanguage::getError($key);
	}

	/**
	 * Get a label from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function lbl($key)
	{
		return FrontendLanguage::getLabel($key);
	}

	/**
	 * Get a message from the language-file
	 *
	 * @param string $key The key to get.
	 * @return string
	 */
	public static function msg($key)
	{
		return FrontendLanguage::getMessage($key);
	}
}
